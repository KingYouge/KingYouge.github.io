---
layout:     post                             
title:      "ES6模块化"            
subtitle:   "ES6的模块化import和export"
date:       2018-11-08 18:00:00              
author:     "YangJin"                        
background: '/assets/img/posts/03.jpg'       
published: true
tags:                                        
    - Module
---

# 理解

>+ require: node 和 es6 都支持的引入,它最早出现于nodejs开发,属于CommonJS规范的一部分
>+ export / import : 只有es6 支持的导出引入
>+ module.exports / exports: 只有 node 支持的导出

## node模块
Node里面模块系统遵循的是CommonJS规范。<br/>
- 什么是CommonJS规范?<br/>
>以前写代码都是比较混乱的，各写各的代码，没有模块这个概念，而这个规范其实就是对模块的一个定义
>CommonJs定义的模块分为：模块标识(module)、模块定义(exports) 、模块引用(require)
- 什么是exports和module.exports
>在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，
而module又有一个exports属性。他们之间的关系如下，都指向一块{}内存区域。

    exports = module.exports = {};
        //utils.js
    let a = 100;

    console.log(module.exports); //能打印出结果为：{}
    console.log(exports); //能打印出结果为：{}

    exports.a = 200; //这里辛苦劳作帮 module.exports 的内容给改成 {a : 200}

    exports = '指向其他内存区'; //这里把exports的指向指走

    //test.js

    var a = require('/utils');
    console.log(a) // 打印为 {a : 200} 
    
>从上面可以看出，其实<code>require</code>导出的内容是<code>module.exports</code>的指向的内存块内容，并不是<code>exports</code>的。
简而言之，区分他们之间的区别就是 <code>exports</code> 只是 <code>module.exports</code>的引用，辅助后者添加内容用的。

用白话讲就是，exports只辅助module.exports操作内存中的数据，辛辛苦苦各种操作数据完，累得要死，结果到最后真正被require出去的内容还是module.exports的，真是好苦逼啊。
其实大家用内存块的概念去理解，就会很清楚了。<br/>

为了避免糊涂，尽量都用 module.exports 导出，然后用require导入。

## ES6中的模块导出导入
说实话，在es中的模块，就非常清晰了。不过也有一些细节的东西需要搞清楚。<br/>
比如 export 和 export default，还有 导入的时候，import a from ..,import {a} from ..，<br/>
总之也有点乱，那么下面我们就开始把它们捋清楚吧<br/>

- export和export default<br/>
它们:
1. export与export default均可用于导出常量、函数、文件、模块等
2. 在一个文件或模块中，export、import可以有多个，export default仅有一个
3. 通过export方式导出，在导入时要加{ }，export default则不需要
4. export能直接导出变量表达式，export default不行。

testEs6Export.js
    //testEs6Export.js
    'use strict'
    //导出变量
    export const a = '100';  

     //导出方法
    export const dogSay = function(){ 
        console.log('wang wang');
    }

     //导出方法第二种
    function catSay(){
       console.log('miao miao'); 
    }
    export { catSay };

    //export default导出
    const m = 100;
    export default m; 
    //export defult const m = 100;// 这里不能写这种格式。
    
    
index.js

    //index.js
    'use strict'
    var express = require('express');
    var router = express.Router();

    import { dogSay, catSay } from './testEs6Export'; //导出了 export 方法 
    import m from './testEs6Export';  //导出了 export default 

    import * as testModule from './testEs6Export'; //as 集合成对象导出



    /* GET home page. */
    router.get('/', function(req, res, next) {
      dogSay();
      catSay();
      console.log(m);
      testModule.dogSay();
      console.log(testModule.m); // undefined , 因为  as 导出是 把 零散的 export 聚集在一起作为一个对象，而export default 是导出为 default属性。
      console.log(testModule.default); // 100
      res.send('恭喜你，成功验证');
    });

    module.exports = router;



------------------
[原文地址](https://segmentfault.com/a/1190000010426778)<br/>
[参考地址](https://segmentfault.com/a/1190000010759267.com/a/1190000010426778)

------------------
##require

CommonJS 作为 Node.js 的规范，一直沿用至今。</br>
由于 npm 上 CommonJS 的类库众多，以及 CommonJS 和 ES6 之间的差异，Node.js 无法直接兼容 ES6。</br>
所以现阶段 require/exports 任然是必要且实必须的。出自 ES6 的 import/export 相对就晚了许多。</br>
被大家所熟知和使用也是 2015 年之后的事了。 </br>
这其实要感谢 babel（原来项目名叫做 6to5，后更名为 babel） 这个神一般的项目。</br>
由于有了 babel 将还未被宿主环境（各浏览器、Node.js）直接支持的 ES6 Module 编译为 ES5 的 CommonJS </br>
也就是 require/exports 这种写法 Webpack 插上 babel-loader 这个翅膀才开始高飞，大家也才可以称 " 我在使用 ES6！"</br>

- require
    var test = require('./moduleTest.js');

    console.log(test(1, 2));
    console.log(mutiply(1, 2));
使用是比较简单的，使用变量获取导出的对象exports，就可以使用对象里面的方法了，我们有的时候可能会遇到这样的情况，无需使用变量接受模块的exports


# 使用
## 说明
该工程是基于vue-cli搭建
- npm install
- npm run dev
## 文件说明
+ 导出
<code>src/assets/js</code>
+ 导入
<code>src/main</code>
